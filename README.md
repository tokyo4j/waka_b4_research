# b4_research
卒業論文用リポジトリ

## Title
プロセス状態遷移のログを利用したスケジューラのモニタリング

## Abstract
オペレーティングシステムにおけるスケジューラは, クラッシュやデッドロックのような明確な障害を伴わないため,
意図した通りに CPU 時間の割り当てが行われているかどうかを確認することが難しい.
実際, Linux 標準搭載のスケジューラであっても, いまだに不具合が報告されている.
本研究では, スケジューリングイベントが発生した際のプロセス状態を時系列順に記録することで,
各コアで実行されるプロセスの遷移をモニタリングする手法を提案する.
また, 教育用オペレーティングシステム xv6 において,
プロセス状態について収集したログを元にスケジューラの問題点の発見から公平性の改善を行うまでの一連の流れを示す.

## Implementation
以下に示すような Kernel の拡張を行った

### Scheduler
- Multiple runrueue に対応した scheduler の追加
+ Work Stealing の実装

### Logging
測定用に, 2つ system callを追加
- bufwrite
bufwrite.c を実行し, ログをバッファに自動的に記録する
- bufread
bufwrite system call で記録されたログを print する

### Workloads
測定時に実行するワークロードも実装
- CPU-intensive なタスク
- I/O-intensive なタスク
- 上記の混合タスク
- xv6 の fairness を崩すようなタスク
など

## Discussion
### CPU-intensive なタスクについて
- プロセスの個数が 1 〜 2 のときは, CPU 2, 3 が特に使われていない
- プロセス数 4 のとき, CPU が一切入れ替わることなかった (理由は調査中)
- プロセス数 5 以上の時は動作に致命的な問題点は見られなかった

### I/O-intensive なタスクについて
- CPU-intensive なタスクとは異なりI/O を発行しているので, 各コアで常にプロセスが RUNNING で動いていることは起きず, 細切りのグラフ形状になった
- pid 3 は I/O 処理を行わないにも関わらず RUNNING 状態が長く続いていることが読み取れるが, これは fork を自分一人で全て行っているためであると考えられる
- SLEEPING から復帰した際にも, 前と同じコアで処理が継続するケースが多く見られた
+ CPU-intensive の処理の場合にはこのような現象は見られなかった.

### CPU-intensive, I/O-intensive なタスクを同時に実行した際の挙動
- コアを跨ぐことはあるものの, CPU-intensive なタスクは RUNNING が途切れることはない
- 一方, I/O-intensive なタスクは細切れで実行された
- 両者が同時に実行されることでスケジューリングに不具合が発生することはなく, 想定通りの挙動となった
